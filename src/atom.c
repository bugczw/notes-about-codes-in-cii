/*
一个原子是一个指向一个独特的，不可改变的零或更多的字节序列的指针。大多数原子是指向以空为结束的字符串，
但是一个指向任何字节序列的指针都可以是一个原子。任何原子只能出现一次。通过简单的比较指针，比较两个字
节序列，如果它们指向相同的位置，则是相同的，这就是原子的优点之一。另一个优点是，使用原子节省空间，因
为每个序列只会出现一次。
总结：指向一个不可改变的零或更多字节序列的指针，并且该指针是唯一的，就是原子。
优点：1.比较指针可以判断字节序列是否相同；2.节省空间。
根据概念来理解，原子就是一个指针，它可以是指向一块任何字节序列，上面以字符指针来说，指向的常量区，不
能更改，字节序列；而在指向堆中的可以改变某一个字节的内容。就是原子例子。原子类型，应该包括了所有指针
类型。
应用：原子经常被用作数据结构中的键，而在数据结构中，用任意的字节序列来表示，而不是用整数来表示。
*/

static char rcsid[] = "$Id$";
#include "atom.h"
#include <string.h>
#include "assert.h"
#include <limits.h>
#include "mem.h"

// 计算数组长度的方法，但数组元素作为函数参数时，此方法不可用。
#define NELEMS(x) ((sizeof (x))/(sizeof ((x)[0])))  

// 定义了一个长度为2048的静态指针数组，每个元素是atom * 
//atom在数组中的位置0~2047，代表hash对应位置，然后buckets[k]又作为表头构成一个指针 
//？为什么要用静态
static struct atom {
	struct atom *link;
	int len;
	char *str;
} *buckets[2048];
//一个buckets指向一个atom序列
//buckets储存键值，一个带符号数字序列

// 散列数组，用于计算hash表的key值，作为buckets的下标索引值，见过字节数映射到随机数
static unsigned long scatter[] = {
2078917053, 143302914, 1027100827, 1953210302, 755253631, 2002600785,
1405390230, 45248011, 1099951567, 433832350, 2018585307, 438263339,
813528929, 1703199216, 618906479, 573714703, 766270699, 275680090,
1510320440, 1583583926, 1723401032, 1965443329, 1098183682, 1636505764,
980071615, 1011597961, 643279273, 1315461275, 157584038, 1069844923,
471560540, 89017443, 1213147837, 1498661368, 2042227746, 1968401469,
1353778505, 1300134328, 2013649480, 306246424, 1733966678, 1884751139,
744509763, 400011959, 1440466707, 1363416242, 973726663, 59253759,
1639096332, 336563455, 1642837685, 1215013716, 154523136, 593537720,
704035832, 1134594751, 1605135681, 1347315106, 302572379, 1762719719,
269676381, 774132919, 1851737163, 1482824219, 125310639, 1746481261,
1303742040, 1479089144, 899131941, 1169907872, 1785335569, 485614972,
907175364, 382361684, 885626931, 200158423, 1745777927, 1859353594,
259412182, 1237390611, 48433401, 1902249868, 304920680, 202956538,
348303940, 1008956512, 1337551289, 1953439621, 208787970, 1640123668,
1568675693, 478464352, 266772940, 1272929208, 1961288571, 392083579,
871926821, 1117546963, 1871172724, 1771058762, 139971187, 1509024645,
109190086, 1047146551, 1891386329, 994817018, 1247304975, 1489680608,
706686964, 1506717157, 579587572, 755120366, 1261483377, 884508252,
958076904, 1609787317, 1893464764, 148144545, 1415743291, 2102252735,
1788268214, 836935336, 433233439, 2055041154, 2109864544, 247038362,
299641085, 834307717, 1364585325, 23330161, 457882831, 1504556512,
1532354806, 567072918, 404219416, 1276257488, 1561889936, 1651524391,
618454448, 121093252, 1010757900, 1198042020, 876213618, 124757630,
2082550272, 1834290522, 1734544947, 1828531389, 1982435068, 1002804590,
1783300476, 1623219634, 1839739926, 69050267, 1530777140, 1802120822,
316088629, 1830418225, 488944891, 1680673954, 1853748387, 946827723,
1037746818, 1238619545, 1513900641, 1441966234, 367393385, 928306929,
946006977, 985847834, 1049400181, 1956764878, 36406206, 1925613800,
2081522508, 2118956479, 1612420674, 1668583807, 1800004220, 1447372094,
523904750, 1435821048, 923108080, 216161028, 1504871315, 306401572,
2018281851, 1820959944, 2136819798, 359743094, 1354150250, 1843084537,
1306570817, 244413420, 934220434, 672987810, 1686379655, 1301613820,
1601294739, 484902984, 139978006, 503211273, 294184214, 176384212,
281341425, 228223074, 147857043, 1893762099, 1896806882, 1947861263,
1193650546, 273227984, 1236198663, 2116758626, 489389012, 593586330,
275676551, 360187215, 267062626, 265012701, 719930310, 1621212876,
2108097238, 2026501127, 1865626297, 894834024, 552005290, 1404522304,
48964196, 5816381, 1889425288, 188942202, 509027654, 36125855,
365326415, 790369079, 264348929, 513183458, 536647531, 13672163,
313561074, 1730298077, 286900147, 1549759737, 1699573055, 776289160,
2143346068, 1975249606, 1136476375, 262925046, 92778659, 1856406685,
1884137923, 53392249, 1735424165, 1602280572
};//43*6-2=256个元素


const char *Atom_string(const char *str) {
	assert(str);
	return Atom_new(str, strlen(str));
}
const char *Atom_int(long n) {
	char str[43];          //43魔数
	//任意128位有符号数，八进制下字符串可以放到128/3+1=43个字符中（严格是127/3+1=44），而十进制不会比八进制多
	char *s = str + sizeof str;//！！！技巧：分配连续的内存，通过s--给str赋值，从而能够使十进制转化时从低位开始赋值
	unsigned long m;
	
	// 简单一点就是需要处理有符号数
	//比如char的范围是-128~127，CHAR_MIN=-128 CHAR_MAX=127, 则如果n=-128, m=127+1,然后转换为字符串后再加上‘-’号   
    // 此处用的是long道理一样，int和char型小于范围小于long，所以如果遇到-128直接执行m=-n;      
	if (n == LONG_MIN)
		m = LONG_MAX + 1UL;// 在limits.h中LONG_MAX 2147483647L LONG_MIN (-LONG_MAX-1)，1UL 表示 无符号长整型 1
	else if (n < 0)
		m = -n;
	else
		m = n;
	//m变成n的绝对值，同时考虑了越界情况
	// 符号'-'在do while循环中不好处理，单独通过if(n<0)来判断，补充上符号。 
	
	do
		*--s = m%10 + '0';
	while ((m /= 10) > 0);
	if (n < 0)
		*--s = '-';
	return Atom_new(s, (str + sizeof str) - s);
}

//创建字符串的原子节点,添加到buckets中的桶中去，通过计算得到hash的h值添加到对应的原子atom列表中
//如果已经存在此str内容，则直接返回已存在的节点内容。  
//str不在表中，则 对序列str计算一个哈希码，将该哈希码对哈希桶的数目取模得到一个索引值，并搜索该索引值对应的哈希桶（即链表）
const char *Atom_new(const char *str, int len) {
	unsigned long h;
	int i;
	struct atom *p;
	assert(str);
	assert(len >= 0);
	for (h = 0, i = 0; i < len; i++)
		h = (h<<1) + scatter[(unsigned char)str[i]];
	//scatter是一个256项的数组，将字节值映射成随机数，随机数调用库函数rand生成
	h &= NELEMS(buckets)-1;//与2047按位取与
	//hash构造，查表算法，按位取与限制h的大小0~2047
	//理想情况下，对N个输入序列，哈希码应均匀分布在NELEMS（bucketd)-1的范围内
	//每个链表有N/NELEMS(buckets)个表项，搜索一个字节系列的平均时间是N/NELEMS(buckets)/2
	//若N<NELEMS(buckets)*2，则时间是一个常数
	
	
    // buckets[h]为链表头，对每个节点p进行判断，看内容是否与传入参数str相同，直到找到或者p=NULL 
	for (p = buckets[h]; p; p = p->link)
		if (len == p->len) {
			for (i = 0; i < len && p->str[i] == str[i]; )//从0开始挨个比对节点p->str中的元素与传入参数str中的元素是否相等，如果相等比对一下个i  
				i++;
			if (i == len) // 如果i==len,证明p->str中的内容与传入的str完全一致，不用重新new一个，直接返回p->str指针 
				return p->str;
		}
	
	// ，如果在节点中未找到对应的str内容，则重新分配空间new一个，这里分配了atom原子结构体长度+len+1,atom结钩体是每个节点的表头      
    // 包含struct atom *link, int len和char * str,如果是32位系统则长度是12，可以通过sizeof(*p)或者NELEMS打印确认，      
    // 长度len是传入参数str内容的长度，+1是结尾补充'\0'的分配的1字节空间     
	//sizeof (*p)为link，len分配内存
	p = ALLOC(sizeof (*p) + len + 1);//内存分配这么大？？？
	//不能使用Mem接口的new，因为new径当分配的字节数在编译时已知才行
	p->len = len;
	p->str = (char *)(p + 1);  
	// p+1的值刚好是跳过表头12的地址，即之前分配的len+1的空间，用于存储str的内容。 
	//为什么要这样子分配？？？
	if (len > 0)
		memcpy(p->str, str, len);
	p->str[len] = '\0';
	p->link = buckets[h];
	 // 将新创建的节点插入到buckets[h]的链表中，插入方式为替换链表head节点，新建单元作为head     
	
	buckets[h] = p;
	return p->str;
}


//不直接计算str的长度，实现只能对原子调用
int Atom_length(const char *str) {
	struct atom *p;
	int i;
	assert(str);
	for (i = 0; i < NELEMS(buckets); i++)
		for (p = buckets[i]; p; p = p->link)
			if (p->str == str)
				return p->len;
	assert(0);//设置异常中断，不返回0，假定不会发生的情况，因此只能对原子调用，而不能对指向其他字符串的指针调用
	return 0;
}
